/*
 *  Flingbox - An OpenSource physics sandbox for Google's Android
 *  Copyright (C) 2009  Jon Ander Peñalba & Endika Gutiérrez
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package edu.eside.flingbox.physics.collisions;

import edu.eside.flingbox.math.Vector2D;
import edu.eside.flingbox.physics.PhysicBody;

/**
 * Contact solver solves contacts between two bodies and applies necessaries 
 * forces over each body.
 * This class has all members static due performance improvement
 */
public class ContactSolver {
	/**
	 * Minimal time unit
	 */
	private final static float DIFFERENTIAL_TIME = 10f / 1000f;
	
	/** Prevent solver creation */
	private ContactSolver() { } 
	
	/**
	 * Computes contacts effects to body's
	 * 
	 * @param contact contact descriptor
	 * @param bodyA first colliding body
	 * @param bodyB second colliding body
	 */
	public static void solveContact(final Contact contact) {
		final PhysicBody bodyA = contact.bodyInContactA; 
		final PhysicBody bodyB = contact.bodyInContactB; 
		
		final float restit = (bodyA.getRestitutionCoeficient() + bodyB.getRestitutionCoeficient()) / 2;
		final float mA = bodyA.getBodyMass();
		final float mB = bodyB.getBodyMass();
		
		Vector2D velA = getVelocityIntoContactAxis(contact, bodyA);
		Vector2D velB = getVelocityIntoContactAxis(contact, bodyB);
		
		if (!bodyA.isFixed()) { 
			/* compute resultant velocity after collision */
			final float vFinal = bodyB.isFixed() 
						? -velA.i * restit
						: ((1 + restit) * mB * velB.i + velA.i * (mA + restit * mB)) / (mA + mB);
						
			final float normalModule = (vFinal - velA.i) * mA / DIFFERENTIAL_TIME;
			
			final Vector2D normalForce = new Vector2D(contact.normal).mul(normalModule);
			final Vector2D frictionForce = computeFrictionForce(bodyA, normalModule, velA.j, contact.sense);
			
			final Vector2D contactRelativePoint = new Vector2D(bodyA.getPosition()).sub(contact.position);
			
			bodyA.applyForce(normalForce.add(frictionForce), contactRelativePoint, DIFFERENTIAL_TIME);
		}
		
		if (!bodyB.isFixed()) { 
			/* compute resultant velocity after collision */
			final float vFinal = bodyA.isFixed() 
						? -velB.i * restit
						: ((1 + restit) * mA * velA.i + velB.i * (mB + restit * mA)) / (mA + mB);
			
			final float normalModule = (vFinal - velB.i) * mB / DIFFERENTIAL_TIME;

			final Vector2D normalForce = new Vector2D(contact.normal).mul(normalModule);
			final Vector2D frictionForce = computeFrictionForce(bodyB, normalModule, velB.j, contact.sense);

			final Vector2D contactRelativePoint = new Vector2D(bodyB.getPosition()).sub(contact.position);

			bodyB.applyForce(normalForce.add(frictionForce), contactRelativePoint, DIFFERENTIAL_TIME);
		} 
		
		fixBodysPenetration(contact, bodyA, bodyB);
	}
	
	/**
	 * Computes friction force's module for a given contact normal.
	 * Friction can be static or dynamic, when body's velocity is not enough to exceed
	 * friction, static friction is applied, else dynamic friction is applied 
	 * 
	 * @param body body witch friction will be computed
	 * @param normal normal force generated by the contact
	 * @param bodyVelocity velocity along contact. Velocity should be decompose
	 *  before pass it as a parameter.
	 * @param frictionDirection normalized vector with direction.
	 * @return Friction force vector. it has to be applied along to bodyVelocity
	 */
	private static Vector2D computeFrictionForce(PhysicBody body, float normal, float bodyVelocity, Vector2D frictionDirection) {
		float staticFrictionForce = body.getStaticFrictionCoeficient() * normal;
		
		final float currentVel = Math.abs(bodyVelocity) ;
		final float staticFrictionVelDiff = Math.abs(staticFrictionForce * DIFFERENTIAL_TIME / body.getBodyMass());
		float module;
		/* Check if friction makes too much force */
		if (currentVel < staticFrictionVelDiff) 
			/* Friction force stops body */
			module = -Math.signum(bodyVelocity) * bodyVelocity * body.getBodyMass() / DIFFERENTIAL_TIME;
		else
			/* Friction force can't stop body, and it is constant */
			module = -Math.signum(bodyVelocity) * body.getDynamicFrictionCoeficient() * normal;
		
		return new Vector2D(frictionDirection).mul(module);
	}
	
	/**
	 * Keeps bodies outside for other bodies
	 * 
	 * @param contact contact descriptor
	 * @param bodyA first body in contact
	 * @param bodyB second body in contact
	 */
	private static void fixBodysPenetration(Contact contact, PhysicBody bodyA, PhysicBody bodyB) {
		
	}
	
	/**
	 * Obtains a Vector with velocity components proyected to contact's sense.
	 * In the x axis it returns velocity against the contact
	 * 
	 * @param contact contact
	 * @param body body to be collided
	 * @return velocity components proyected
	 */
	private static Vector2D getVelocityIntoContactAxis(final Contact contact, final PhysicBody body) {
		final Vector2D contactNormal = contact.normal;
		final Vector2D contactSense = contact.sense;
		
		/* Get vector from Polygon's center to contact point  */
		final Vector2D relativeContactPoint = new Vector2D(contact.position).sub(body.getPosition());
		final Vector2D velocityByAngularRotation = 
			Vector2D.normalVector(relativeContactPoint) // This returns new Vector2D, so don't copy
			.normalize()
			.mul(relativeContactPoint.length() 
					* body.getAngularVelocity());
		
		/*
		 * Get total body's total velocity at contact point 
		 * NOTE: velocityByAngularRotation is not duplicated since it won't be longer used.
		 */
		final Vector2D totalVelocity = velocityByAngularRotation.add(body.getVelocity()); 

		/* Check if body moving away contact */
		if (totalVelocity.dotProduct(relativeContactPoint) <= 0) 
			return new Vector2D(); // Velocity is Zero
		
		/* Decompose into components */
		float velAgainstContact = totalVelocity.dotProduct(contactNormal);
		float velAlongContact = totalVelocity.dotProduct(contactSense);
		
		return new Vector2D(velAgainstContact, velAlongContact);
	}
	
}
