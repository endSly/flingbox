diff --git a/src/edu/eside/flingbox/physics/collisions/ContactSolver.java b/src/edu/eside/flingbox/physics/collisions/ContactSolver.java
index 8a577e3..1887a4b 100644
--- a/src/edu/eside/flingbox/physics/collisions/ContactSolver.java
+++ b/src/edu/eside/flingbox/physics/collisions/ContactSolver.java
@@ -61,6 +61,7 @@ public class ContactSolver {
 		/* Get velocity and mass of colliding body */
 		Vector2D relativeVel = getRelativeVelocity(collidingBody, collidedBody, contact);
 		float relativeAgainstVel = relativeVel.dotProduct(contact.normal);
+		
 		final float collidingMass = collidingBody.getBodyMass();
 		
 		/* Compute final velocity */
@@ -82,10 +83,12 @@ public class ContactSolver {
 			final float collidedMass = collidedBody.getBodyMass();
 			diffImpulse = relativeAgainstVel * collidingMass * collidedMass * (1 + restit) / (collidingMass + collidedMass);
 		}
+		
+		Vector2D collidingVelVector = getVelocityIntoContactAxis(contact, collidingBody);
 
 		/* Get resultant impulse as addition of normal and friction */
 		final Vector2D normalImpulse = new Vector2D(contact.normal).mul(diffImpulse);
-		final Vector2D frictionImpulse = computeFrictionImpulse(collidingBody, diffImpulse, relativeVel.dotProduct(contact.sense), contact.sense);
+		final Vector2D frictionImpulse = computeFrictionImpulse(collidingBody, diffImpulse, collidingVelVector.j, contact.sense);
 		final Vector2D collisionImpuse = normalImpulse.add(frictionImpulse);
 		
 		/* Where impulse is applied */
@@ -141,13 +144,38 @@ public class ContactSolver {
 	}
 	
 	/**
-	 * Gets relative velocity between two bodies
+	 * Obtains a Vector with velocity components projected to contact's sense.
+	 * In the x axis it returns velocity against the contact
 	 * 
-	 * @param bodyA
-	 * @param bodyB
-	 * @param contact
-	 * @return relative velocity
+	 * @param contact contact
+	 * @param body body to be collided
+	 * @return velocity components projected
 	 */
+	private static Vector2D getVelocityIntoContactAxis(final Contact contact, final PhysicBody body) {
+		final Vector2D contactNormal = contact.normal;
+		final Vector2D contactSense = contact.sense;
+		
+		/* Get vector from Polygon's center to contact point  */
+		final Vector2D relativeContactPoint = new Vector2D(contact.position).sub(body.getPosition());
+		final Vector2D velocityByAngularRotation = 
+			Vector2D.normalVector(relativeContactPoint).mul(body.getAngularVelocity());
+		
+		/* Get total body's total velocity at contact point 
+		 * NOTE: velocityByAngularRotation is not duplicated since it won't be longer used.
+		 */
+		final Vector2D totalVelocity = velocityByAngularRotation.add(body.getImpulse().mul(1f / body.getBodyMass())); 
+
+		/* Check if body moving away contact */
+		if (!totalVelocity.isAtSameSide(relativeContactPoint /*contact.getBodysSide(body)*/)) 
+			return new Vector2D(); // Velocity is Zero
+		
+		/* Decompose into components */
+		float velAgainstContact = totalVelocity.dotProduct(contactNormal);
+		float velAlongContact = totalVelocity.dotProduct(contactSense);
+		
+		return new Vector2D(velAgainstContact, velAlongContact);
+	}
+	
 	private static Vector2D getRelativeVelocity(final PhysicBody bodyA, final PhysicBody bodyB, final Contact contact) {
 		final Vector2D contactPointA = new Vector2D(contact.position).sub(bodyA.getPosition());
 		final Vector2D contactPointB = new Vector2D(contact.position).sub(bodyB.getPosition());
@@ -158,6 +186,11 @@ public class ContactSolver {
 		relativeVel.sub(bodyA.getVelocity());
 		relativeVel.sub(Vector2D.normalVector(contactPointA).mul(bodyA.getAngularVelocity()));
 		
+		Vector2D relativePosition = new Vector2D(bodyB.getPosition()).sub(bodyB.getPosition());
+		
+		if (relativePosition.crossProduct(relativeVel) > 0)
+			return new Vector2D();
+		
 		return relativeVel;
 	}
 	
